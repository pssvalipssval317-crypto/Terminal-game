<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sensor Task Game ‚Äî 40 Missions (Face & Voice)</title>
<style>
  :root{--bg:#000;--fg:#7CFF7C;--muted:#9FFFB1;--accent:#00E676;--danger:#ff6b6b}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-monospace,monospace}
  main{max-width:1000px;margin:0 auto;padding:16px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px}
  h1{margin:0;font-size:18px}
  #status{color:var(--muted);font-size:13px}
  #screen{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06)}
  pre#output{white-space:pre-wrap;min-height:360px;margin:0;padding:10px;overflow:auto}
  #controls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  input#cmd{flex:1;background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:6px;color:var(--fg);outline:none}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:6px;color:var(--fg);cursor:pointer}
  .muted{color:var(--muted)}
  .danger{color:var(--danger)}
  .big { font-size: 16px; padding: 12px 16px; }
  #video, #canvas { display:none; }
  #overlay { position:fixed; left:0; right:0; top:0; bottom:0; background:rgba(0,0,0,0.85); color:var(--fg); display:flex; align-items:center; justify-content:center; z-index:9999; flex-direction:column; gap:12px; padding:20px; }
  #overlay.hidden { display:none; }
  .locked { opacity:0.4; pointer-events:none; }
  .warn { color: #ffd166; }
  .punish { color: var(--danger); font-weight:700; }
  .success { color: var(--accent); font-weight:700; }
  #leaderboard { margin-top:12px; border-top:1px dashed rgba(255,255,255,0.06); padding-top:12px; font-size:13px; color:var(--muted); }
  #leaderboard ol { padding-left:18px; margin:6px 0; }
  .timer { float:right; font-size:12px; color:var(--muted); }
  /* interactive punishments visuals */
  #flash { position:fixed; inset:0; background:#fff; z-index:2000; display:none; }
  #fakeError { position:fixed; inset:0; background:#111; color:#fff; z-index:2001; display:none; align-items:center; justify-content:center; font-size:20px; }
</style>
</head>
<body>
<main>
  <header>
    <h1>Sensor Task Game ‚Äî 40 Missions</h1>
    <div id="status">Score: <span id="score">0</span> ‚Ä¢ Fouls: <span id="foul">0</span> ‚Ä¢ Level: <span id="level">1</span></div>
  </header>

  <section id="screen" role="application" aria-label="terminal">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="flex:1">
        <pre id="output" aria-live="polite"></pre>
      </div>
      <div style="width:220px;padding-left:12px">
        <div id="taskInfo"><strong>Task:</strong><div id="taskTitle" style="margin-top:6px;color:var(--muted)"></div></div>
        <div style="margin-top:8px"><span class="muted">Time left:</span> <span id="timeLeft" class="muted">--</span></div>
        <div id="missionControls" style="margin-top:12px;display:flex;flex-direction:column;gap:8px">
          <button id="startBtn" class="big">Start Game (ask permissions)</button>
          <button id="nextBtn" class="big">Next Task</button>
          <button id="missionsBtn">List Missions</button>
          <button id="resetBtn" class="danger">Reset Game</button>
        </div>
        <div id="leaderboard" style="margin-top:14px">
          <strong>üèÜ Leaderboard (local)</strong>
          <ol id="lb" style="margin-top:6px"></ol>
          <small class="muted">Top 5 (localStorage)</small>
        </div>
      </div>
    </div>

    <div id="controls" style="margin-top:10px">
      <input id="cmd" placeholder="Type CONFIRM or commands and press Enter" />
    </div>

    <small class="muted">Tip: Start Game first to grant permissions; tasks use camera, mic, motion & location if available. Face detection uses browser FaceDetector (if supported).</small>
  </section>

  <!-- Hidden elements used for sensor capture -->
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>
</main>

<div id="overlay" class="hidden">
  <div id="overlayText"></div>
  <div><button id="overlayClose">I CONFIRM</button></div>
</div>

<div id="flash"></div>
<div id="fakeError"><div id="fakeErrorMsg">System Error: Unknown</div><div style="margin-top:12px"><button id="fakeErrorClose">Resume</button></div></div>

<script>
/* Final integrated game:
   - Sensor engine (camera, mic, motion, geo)
   - Face detection via FaceDetector (fallback to manual)
   - Voice-to-Text via Web Speech API (SpeechRecognition)
   - 40 tasks, unique punishments (interactive)
   - Level progression (every 5 tasks)
   - Per-task time limit + relax time
   - Leaderboard (localStorage) and optional API hook commented
*/

// ---------- DOM elements & state ----------
const output = document.getElementById('output');
const startBtn = document.getElementById('startBtn');
const nextBtn = document.getElementById('nextBtn');
const missionsBtn = document.getElementById('missionsBtn');
const resetBtn = document.getElementById('resetBtn');
const cmdInput = document.getElementById('cmd');
const scoreEl = document.getElementById('score');
const foulEl = document.getElementById('foul');
const levelEl = document.getElementById('level');
const taskTitleEl = document.getElementById('taskTitle');
const timeLeftEl = document.getElementById('timeLeft');
const lbEl = document.getElementById('lb');
const overlay = document.getElementById('overlay');
const overlayText = document.getElementById('overlayText');
const overlayClose = document.getElementById('overlayClose');
const flash = document.getElementById('flash');
const fakeError = document.getElementById('fakeError');
const fakeErrorMsg = document.getElementById('fakeErrorMsg');
const fakeErrorClose = document.getElementById('fakeErrorClose');

const video = document.getElementById('video');
const canvas = document.getElementById('canvas');

let score = 0;
let foulCount = 0;
let currentIndex = 0; // 0-based index into tasks[]
let level = 1;
let lockedUntil = 0;
let taskTimer = null;
let countdownInterval = null;
let taskTimeLimit = 15000; // ms (per task)
let relaxTime = 5000; // ms between tasks
let faceDetectorAvailable = ('FaceDetector' in window);
let recognition = null; // SpeechRecognition
let cameraStream = null;
let micStream = null;
let audioCtx = null;
let analyser = null;
let dataArray = null;
let motionActive = false;
let motionHandler = null;
let motionCount = 0;
let rewardsDisabled = false;
let punishmentsSpecialApplied = new Set();
let autoAdvanceTimer = null;

// utility printing
function println(s=''){ output.textContent += s + '\n'; output.scrollTop = output.scrollHeight; }
function setScore(n){ score = n; scoreEl.textContent = score; }
function addScore(n){ score += n; setScore(score); }
function addFoul(){ foulCount++; foulEl.textContent = foulCount; }
function setLevel(n){ level = n; levelEl.textContent = level; }
function showOverlay(msg){ overlayText.innerText = msg; overlay.classList.remove('hidden'); }
function hideOverlay(){ overlay.classList.add('hidden'); }

// ---------- Sensor helpers ----------
async function requestCamera(){
  if (cameraStream) return cameraStream;
  try {
    cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'user' }, audio:false });
    video.srcObject = cameraStream;
    await video.play().catch(()=>{});
    println('[permission] Camera allowed.');
    return cameraStream;
  } catch(e){
    println('[permission] Camera denied/unavailable.');
    cameraStream = null;
    throw e;
  }
}
async function stopCamera(){
  if (!cameraStream) return;
  cameraStream.getTracks().forEach(t => t.stop());
  cameraStream = null;
  video.srcObject = null;
}
async function requestMic(){
  if (micStream) return micStream;
  try {
    micStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioCtx.createMediaStreamSource(micStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    source.connect(analyser);
    println('[permission] Microphone allowed.');
    return micStream;
  } catch(e){
    println('[permission] Microphone denied/unavailable.');
    micStream = null;
    throw e;
  }
}
function stopMic(){
  if (!micStream) return;
  micStream.getTracks().forEach(t => t.stop());
  micStream = null;
  if (audioCtx){ audioCtx.close(); audioCtx = null; analyser=null; dataArray=null; }
}

// brightness average
async function measureBrightness(duration=1500, interval=200){
  try { await requestCamera(); } catch { return null; }
  const ctx = canvas.getContext('2d');
  canvas.width = video.videoWidth || 320;
  canvas.height = video.videoHeight || 240;
  const samples = Math.max(1, Math.floor(duration/interval));
  let total=0;
  for (let i=0;i<samples;i++){
    ctx.drawImage(video,0,0,canvas.width,canvas.height);
    const d = ctx.getImageData(0,0,canvas.width,canvas.height).data;
    let sum=0;
    for (let p=0;p<d.length;p+=4) sum += (0.2126*d[p] + 0.7152*d[p+1] + 0.0722*d[p+2]);
    total += sum/(canvas.width*canvas.height);
    await delay(interval);
  }
  return total/samples;
}

// RMS for sound levels
async function measureSoundRMS(duration=1500, interval=200){
  try { await requestMic(); } catch { return null; }
  const samples = Math.max(1, Math.floor(duration/interval));
  let total=0;
  for (let i=0;i<samples;i++){
    analyser.getByteTimeDomainData(dataArray);
    let sum=0;
    for (let j=0;j<dataArray.length;j++){
      const v = (dataArray[j]-128)/128;
      sum += v*v;
    }
    const rms = Math.sqrt(sum/dataArray.length);
    total += rms;
    await delay(interval);
  }
  return total/samples;
}

// motion counting (for shakes/steps)
function startMotionCounting(){
  if (motionActive) return;
  motionCount = 0;
  motionHandler = (ev)=>{
    const a = ev.accelerationIncludingGravity || ev.acceleration || {};
    const mag = Math.sqrt((a.x||0)**2 + (a.y||0)**2 + (a.z||0)**2);
    if (mag > 15) motionCount++;
  };
  if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
    DeviceMotionEvent.requestPermission().then(res=>{
      if (res==='granted') window.addEventListener('devicemotion', motionHandler);
    }).catch(()=>{/* ignore */});
  } else {
    window.addEventListener('devicemotion', motionHandler);
  }
  motionActive = true;
}
function stopMotionCounting(){
  if (!motionActive) return;
  window.removeEventListener('devicemotion', motionHandler);
  motionActive = false;
}

// geolocation
function getPosition(timeout=7000){
  return new Promise(resolve=>{
    if (!('geolocation' in navigator)) return resolve(null);
    navigator.geolocation.getCurrentPosition(pos=>resolve(pos), err=>resolve(null), { timeout });
  });
}

// face detect wrapper using built-in FaceDetector (if available)
async function detectFace(timeout=2000){
  try { await requestCamera(); } catch { return {available:false}; }
  if (!faceDetectorAvailable) return {available:false};
  const fd = new FaceDetector({ fastMode:true, maxDetectedFaces:1 });
  const ctx = canvas.getContext('2d');
  canvas.width = video.videoWidth || 320;
  canvas.height = video.videoHeight || 240;
  const start = Date.now();
  while (Date.now() - start < timeout){
    ctx.drawImage(video,0,0,canvas.width,canvas.height);
    try {
      const faces = await fd.detect(canvas);
      if (faces && faces.length > 0) return {available:true, faces};
    } catch(e){ break; }
    await delay(150);
  }
  return {available:true, faces:[]};
}

// small helpers
function delay(ms){ return new Promise(r=>setTimeout(r, ms)); }
function rand(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

// ---------- UI punishments (interactive) ----------
async function punishmentFlash(duration=8000){
  println('Punishment: BLINDING flash for '+(duration/1000)+'s');
  flash.style.display = 'block';
  await delay(duration);
  flash.style.display = 'none';
}
async function punishmentShake(duration=2000){
  println('Punishment: SCREEN SHAKE for '+(duration/1000)+'s');
  const body = document.body;
  const start = Date.now();
  const id = setInterval(()=>{ body.style.transform = `translate(${(Math.random()*10-5).toFixed(1)}px, ${(Math.random()*10-5).toFixed(1)}px)`; }, 45);
  await delay(duration);
  clearInterval(id);
  body.style.transform = '';
}
async function punishmentFakeError(duration=5000){
  println('Punishment: Fake System Error screen for '+(duration/1000)+'s');
  fakeErrorMsg.innerText = 'SYSTEM ERROR ‚Äî recover in progress...';
  fakeError.style.display = 'flex';
  return new Promise(res=>{
    const handler = ()=>{ fakeError.style.display='none'; fakeErrorClose.removeEventListener('click', handler); res(true); };
    fakeErrorClose.addEventListener('click', handler);
    setTimeout(()=>{ if (fakeError.style.display==='flex'){ fakeError.style.display='none'; fakeErrorClose.removeEventListener('click', handler); res(true); } }, duration);
  });
}
async function punishmentSound(url='https://actions.google.com/sounds/v1/alarms/beep_short.ogg'){
  try { const a = new Audio(url); a.play().catch(()=>{}); println('Punishment: Playing sound'); await delay(2000); } catch(e){ println('Sound error'); }
}
async function punishmentLock(ms, reason='Locked') {
  println(`Punishment: UI locked for ${Math.ceil(ms/1000)}s ‚Äî ${reason}`);
  const screenEl = document.getElementById('screen');
  screenEl.classList.add('locked');
  lockedUntil = Date.now() + ms;
  await delay(ms);
  screenEl.classList.remove('locked');
  println('Lock ended.');
}
async function punishmentScoreLoss(n){
  println(`Punishment: -${n} points`);
  addScore(-n);
}
async function punishmentResetTo(idx){
  println(`Punishment: Progress reset to task #${idx+1}`);
  currentIndex = Math.max(0, idx);
}

// ---------- leaderboard (local) ----------
function loadLeaderboard(){ return JSON.parse(localStorage.getItem('leaderboard_v1') || '[]'); }
function saveLeaderboard(list){ localStorage.setItem('leaderboard_v1', JSON.stringify(list)); renderLeaderboard(); }
function submitScore(name, points){
  // local store
  const list = loadLeaderboard();
  list.push({name, points, ts: Date.now()});
  list.sort((a,b)=>b.points - a.points);
  saveLeaderboard(list.slice(0,5));
  // optional: post to your online API here (uncomment & change URL)
  // fetch('https://your-server/scores', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({name,points})});
}
function renderLeaderboard(){
  const list = loadLeaderboard();
  lbEl.innerHTML = '';
  list.forEach((r,i)=>{
    const li = document.createElement('li');
    li.textContent = `${i+1}. ${r.name} ‚Äî ${r.points}`;
    lbEl.appendChild(li);
  });
}

// ---------- manual confirm overlay (fallback) ----------
function manualConfirm(timeout=30000){
  return new Promise(resolve=>{
    overlay.classList.remove('hidden');
    const onClick = ()=>{ cleanup(); resolve(true); };
    function cleanup(){ overlayClose.removeEventListener('click', onClick); overlay.classList.add('hidden'); }
    overlayClose.addEventListener('click', onClick);
    setTimeout(()=>{ cleanup(); resolve(false); }, timeout);
  });
}

// ---------- Speech recognition (voice-to-text) ----------
function initSpeech(){
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) { println('[voice] Web Speech API not supported. Voice tasks will fallback.'); return null; }
  const r = new SpeechRecognition();
  r.lang = 'en-US';
  r.interimResults = false;
  r.maxAlternatives = 3;
  println('[voice] SpeechRecognition available.');
  return r;
}
function recognizeOnce(timeout=5000){
  return new Promise(resolve=>{
    if (!recognition){ resolve(null); return; }
    let done=false;
    const onResult = (e)=>{
      if (done) return;
      done=true;
      const txt = e.results[0][0].transcript;
      cleanup();
      resolve(txt);
    };
    const onError = ()=>{ if (!done){ done=true; cleanup(); resolve(null); } };
    const cleanup = ()=>{ recognition.removeEventListener('result', onResult); recognition.removeEventListener('error', onError); try{ recognition.stop(); }catch{} };
    recognition.addEventListener('result', onResult);
    recognition.addEventListener('error', onError);
    try{ recognition.start(); } catch(e){ cleanup(); resolve(null); }
    // timeout
    setTimeout(()=>{ if (!done){ done=true; cleanup(); resolve(null); } }, timeout);
  });
}

// ---------- Tasks registration ----------
const tasks = []; // will hold {id,title,desc,reward,checkFn,punishmentFn,timeLimit}

function addTask(id,title,desc,reward,checkFn,punishmentFn,timeLimit=15000){
  tasks.push({id,title,desc,reward,checkFn,punishmentFn,timeLimit});
}

/* ------------- Create 40 tasks ------------- 
   For brevity I model many with sensors; when sensor missing -> fallbackConfirm.
   Each task has unique punishment using functions above.
*/

// Task 1: Dark room (camera brightness)
addTask(1,'Dark room','Sit in a dark place. Camera checks brightness.',10,
  async ()=> {
    const lum = await measureBrightness(1800,250);
    if (lum === null) { println('Camera unavailable ‚Äî fallback confirm.'); return await manualConfirm(20000); }
    println('Brightness: '+lum.toFixed(1));
    return lum < 35;
  },
  async ()=>{ await punishmentFlash(8000); await punishmentScoreLoss(20); },
  20000
);

// Task 2: Be silent 20s (mic)
addTask(2,'Silent 20s','Stay quiet for 20 seconds; mic measures RMS.',15,
  async ()=> {
    const rms = await measureSoundRMS(20000,500);
    if (rms === null) { println('Mic unavailable ‚Äî fallback confirm.'); return await manualConfirm(15000); }
    println('Avg RMS: '+rms.toFixed(4));
    return rms < 0.018;
  },
  async ()=>{ await punishmentLock(30000,'Input locked'); await punishmentScoreLoss(15); },
  30000
);

// Task 3: Hold still 12s (motion)
addTask(3,'Hold still','Keep device steady for 12s (no shakes).',20,
  async ()=> {
    let moved=false;
    function handler(ev){ const a=ev.accelerationIncludingGravity||{}; const mag=Math.sqrt((a.x||0)**2+(a.y||0)**2+(a.z||0)**2); if (mag>4) moved=true; }
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      const r = await DeviceMotionEvent.requestPermission().catch(()=>null);
      if (r!=='granted') return await manualConfirm(12000);
    }
    window.addEventListener('devicemotion', handler);
    await delay(12000);
    window.removeEventListener('devicemotion', handler);
    return !moved;
  },
  async ()=>{ await punishmentScoreLoss(Math.floor(score/2)); },
  20000
);

// Task 4: Flat device (orientation)
addTask(4,'Flat device','Place phone flat with screen up for 8s.',15,
  async ()=> {
    const o = await readOrientationOnce(3000);
    if (!o) return await manualConfirm(8000);
    println('beta: '+(o.beta||0).toFixed(1));
    return Math.abs((o.beta||0)) < 25;
  },
  async ()=>{ println('Punishment: next tasks faster'); nextTimeoutMultiplier = 0.6; await delay(100); },
  15000
);

// Task 5: Min screen brightness (proxy)
addTask(5,'Low screen','Reduce your screen brightness (proxy).',10,
  async ()=> {
    const lum = await measureBrightness(1400,300);
    if (lum === null) return await manualConfirm(10000);
    println('screen proxy lum: '+lum.toFixed(1));
    return lum < 50;
  },
  async ()=>{ await punishmentScoreLoss(30); addFoul(); },
  15000
);

// Task 6: Point to sky
addTask(6,'Point sky','Point camera to bright sky for 3s.',20,
  async ()=> {
    const lum = await measureBrightness(1500,250);
    if (lum === null) return await manualConfirm(10000);
    return lum > 120;
  },
  async ()=>{ await punishmentResetTo(0); },
  15000
);

// Task 7: Exactly 3 shakes
addTask(7,'Three shakes','Shake your device roughly 3 times in 8 seconds.',25,
  async ()=> {
    startMotionCounting(); motionCount=0; await delay(8000); stopMotionCounting();
    println('shakes: '+motionCount);
    return motionCount===3;
  },
  async ()=>{ // require 5 manual confirms as punishment
    println('Punishment: confirm 5 times quickly.');
    for (let i=0;i<5;i++){
      const ok = await manualConfirm(20000);
      if (!ok){ await punishmentScoreLoss(10); break; }
    }
  },
  12000
);

// Task 8: No touch 45s
addTask(8,'No touch 45s','Do not touch the screen for 45 seconds.',50,
  async ()=> {
    let touched=false;
    function handler(){ touched=true; }
    window.addEventListener('touchstart', handler, {passive:true});
    await delay(45000);
    window.removeEventListener('touchstart', handler);
    return !touched;
  },
  async ()=>{ await punishmentScoreLoss(100); addFoul(); },
  50000
);

// Task 9: Quiet 12s
addTask(9,'Quiet 12s','Keep ambient noise low for 12 seconds.',30,
  async ()=> {
    const rms = await measureSoundRMS(12000,300);
    if (rms === null) return await manualConfirm(10000);
    println('RMS: '+rms.toFixed(4));
    return rms < 0.015;
  },
  async ()=>{ println('Punishment: rewards halved until next success'); rewardsDisabled='half'; },
  15000
);

// Task 10: Face present
addTask(10,'Face present','Show your face to the camera.',15,
  async ()=> {
    const res = await detectFace(3000);
    if (!res.available) return await manualConfirm(8000);
    return (res.faces && res.faces.length>0);
  },
  async ()=>{ await punishmentScoreLoss(40); },
  12000
);

// Task 11: Share location
addTask(11,'Share location','Allow geolocation and show position.',12,
  async ()=> {
    const pos = await getPosition(6000);
    if (!pos) return false;
    println(`Lat ${pos.coords.latitude.toFixed(5)} Lon ${pos.coords.longitude.toFixed(5)}`);
    return true;
  },
  async ()=>{ await punishmentScoreLoss(20); punishmentsSpecialApplied.add('disableGPS'); setTimeout(()=>punishmentsSpecialApplied.delete('disableGPS'),2*60000); },
  15000
);

// Task 12: Memory 7-2-9
addTask(12,'Memory test','Memorize 7-2-9 and type it back.',10,
  async ()=> {
    println('Memorize: 7-2-9');
    await delay(4000);
    const ok = await promptConfirm('Type 7-2-9 now:',8000,'7-2-9');
    return ok;
  },
  async ()=>{ await punishmentScoreLoss(10); nextTimeoutMultiplier = 0.6; setTimeout(()=>nextTimeoutMultiplier=1,2*60000); },
  15000
);

// Task 13: Sip water
addTask(13,'Sip water','Take a sip and confirm (manual).',8,
  async ()=> { return await manualConfirm(12000); },
  async ()=>{ await punishmentScoreLoss(12); },
  15000
);

// Task 14: Whistle (mic)
addTask(14,'Whistle','Whistle for 2 seconds into mic.',15,
  async ()=> {
    const rms = await measureSoundRMS(2000,100);
    if (rms === null) return await manualConfirm(8000);
    println('RMS: '+rms.toFixed(4));
    return rms > 0.03;
  },
  async ()=>{ await punishmentScoreLoss(18); punishmentsSpecialApplied.add('harsh'); },
  10000
);

// Task 15: Cover camera 2s
addTask(15,'Cover camera','Cover camera for 2 seconds.',12,
  async ()=> {
    const b1 = await measureBrightness(600,200);
    const b2 = await measureBrightness(1200,300);
    if (b1===null||b2===null) return await manualConfirm(8000);
    return b2 < b1*0.25;
  },
  async ()=>{ await punishmentScoreLoss(25); },
  10000
);

// Task 16: Show red object
addTask(16,'Show red','Point camera at a red object.',12,
  async ()=> {
    try{ await requestCamera(); } catch { return await manualConfirm(8000); }
    const ctx = canvas.getContext('2d'); canvas.width=video.videoWidth||320; canvas.height=video.videoHeight||240;
    let total=0;
    for (let s=0;s<3;s++){ ctx.drawImage(video,0,0,canvas.width,canvas.height); const d = ctx.getImageData(0,0,canvas.width,canvas.height).data; let rsum=0; for (let p=0;p<d.length;p+=4) rsum += d[p]; total += rsum/(canvas.width*canvas.height); await delay(300);}
    const avg = total/3; println('avg red:'+avg.toFixed(1));
    return avg>70;
  },
  async ()=>{ await punishmentScoreLoss(20); if (currentIndex>0) currentIndex--; },
  12000
);

// Task 17: Whisper (mic)
addTask(17,'Whisper name','Whisper your codename into mic.',10,
  async ()=> {
    const rms = await measureSoundRMS(2500,200);
    if (rms===null) return await manualConfirm(8000);
    println('RMS: '+rms.toFixed(4));
    return rms>0.01 && rms<0.06;
  },
  async ()=>{ await punishmentScoreLoss(15); punishmentsSpecialApplied.add('muteRewards'); setTimeout(()=>punishmentsSpecialApplied.delete('muteRewards'),60000); },
  12000
);

// Task 18: Night check (time)
addTask(18,'Night check','This mission succeeds only if local time is between 22:00 and 05:00.',30,
  async ()=> {
    const h = new Date().getHours();
    println('Hour: '+h);
    return (h>=22 || h<=5);
  },
  async ()=>{ await punishmentScoreLoss(25); currentIndex = Math.max(9, currentIndex-1); },
  8000
);

// Task 19: High contrast
addTask(19,'High contrast','Show black/white pattern to camera.',14,
  async ()=> {
    try{ await requestCamera(); } catch { return await manualConfirm(8000); }
    const ctx = canvas.getContext('2d'); canvas.width=video.videoWidth||320; canvas.height=video.videoHeight||240;
    ctx.drawImage(video,0,0,canvas.width,canvas.height); const d=ctx.getImageData(0,0,canvas.width,canvas.height).data;
    let dark=0, bright=0;
    for (let p=0;p<d.length;p+=4){ const lum = 0.2126*d[p]+0.7152*d[p+1]+0.0722*d[p+2]; if (lum<40) dark++; if (lum>215) bright++; }
    const ratio = (dark+bright)/(canvas.width*canvas.height);
    println('contrast %: '+(ratio*100).toFixed(1));
    return ratio>0.18;
  },
  async ()=>{ await punishmentScoreLoss(18); currentIndex--; },
  12000
);

// Task 20: Two claps
addTask(20,'Two claps','Clap twice in 3 seconds.',16,
  async ()=> {
    try{ await requestMic(); } catch { return await manualConfirm(8000); }
    const ms = 3000, interval=100, steps = ms/interval; const arr=[];
    for (let i=0;i<steps;i++){ analyser.getByteTimeDomainData(dataArray); let sum=0; for (let j=0;j<dataArray.length;j++){ const v=(dataArray[j]-128)/128; sum+=v*v; } arr.push(Math.sqrt(sum/dataArray.length)); await delay(interval); }
    const peaks = arr.filter(x=>x>0.08).length;
    println('peaks: '+peaks);
    return peaks>=2;
  },
  async ()=>{ await punishmentScoreLoss(20); addFoul(); },
  8000
);

// Task 21: Quick reaction (Enter)
addTask(21,'Reaction test','When GO appears press Enter quickly.',12,
  async ()=> {
    println('Get ready... GO in 1s');
    await delay(1000); println('GO!');
    const ok = await waitForEnter(3000);
    return ok;
  },
  async ()=>{ await punishmentScoreLoss(12); punishmentsSpecialApplied.add('skipNextReward'); setTimeout(()=>punishmentsSpecialApplied.delete('skipNextReward'),30000); },
  6000
);

// Task 22: Balance (manual)
addTask(22,'Balance','Stand on one leg for 8s (manual confirm).',18,
  async ()=> { return await manualConfirm(15000); },
  async ()=>{ await punishmentScoreLoss(22); },
  15000
);

// Task 23: Blink detect (heuristic)
addTask(23,'Blink','Look at camera and blink once (heuristic).',12,
  async ()=> {
    if (!faceDetectorAvailable) return await manualConfirm(9000);
    const r1 = await detectFace(1500); await delay(300); const r2 = await detectFace(1500);
    const p1 = r1.faces && r1.faces.length>0; const p2 = r2.faces && r2.faces.length>0;
    return (p1 && !p2);
  },
  async ()=>{ await punishmentScoreLoss(15); addFoul(); },
  10000
);

// Task 24: Face-down detect
addTask(24,'Face-down','Place phone face-down for 4s.',10,
  async ()=> {
    const o = await readOrientationOnce(3000);
    if (!o) return await manualConfirm(8000);
    const b = o.beta||0;
    return Math.abs(Math.abs(b)-180) < 30;
  },
  async ()=>{ await punishmentScoreLoss(18); lockedUntil = Date.now()+8000; lockUIFor(8000,'Locked due to failure'); },
  10000
);

// Task 25: Move a few meters (GPS)
addTask(25,'Move short distance','Move a few meters (GPS) within ~12s.',25,
  async ()=> {
    const p1 = await getPosition(7000); if (!p1) return await manualConfirm(15000);
    println(`start ${p1.coords.latitude.toFixed(5)},${p1.coords.longitude.toFixed(5)}`);
    await delay(12000);
    const p2 = await getPosition(7000); if (!p2) return false;
    const dx=(p2.coords.latitude-p1.coords.latitude)*111000; const dy=(p2.coords.longitude-p1.coords.longitude)*111000*Math.cos(p1.coords.latitude*Math.PI/180);
    const dist=Math.sqrt(dx*dx+dy*dy); println('moved m: '+Math.round(dist));
    return dist>8;
  },
  async ()=>{ await punishmentScoreLoss(30); currentIndex = 19; },
  24000
);

// Task 26: Riddle
addTask(26,'Riddle','What has keys but no locks? (type answer)',10,
  async ()=> { return await promptConfirm('Answer:',10000,'piano|keyboard'); },
  async ()=>{ await punishmentScoreLoss(10); punishmentsSpecialApplied.add('harsh'); },
  10000
);

// Task 27: Torch spike (proxy)
addTask(27,'Torch spike','Use torch to create a bright spike.',14,
  async ()=> {
    const b1 = await measureBrightness(800,200); await delay(1200); const b2 = await measureBrightness(1200,150);
    if (b1===null||b2===null) return await manualConfirm(10000);
    return b2 > b1*1.8;
  },
  async ()=>{ await punishmentScoreLoss(20); },
  12000
);

// Task 28: Head left & right (face detection)
addTask(28,'Head left & right','Turn head left then right within 6s (face detection heuristic).',18,
  async ()=> {
    if (!faceDetectorAvailable) return await manualConfirm(8000);
    println('Look center, then left then right');
    const left = await (async ()=>{ const r=await detectFace(2000); if (!r.faces) return false; const box=r.faces[0].boundingBox; const cx=box.x+box.width/2; return cx < (video.videoWidth||320)*0.4; })();
    await delay(300);
    const right = await (async ()=>{ const r=await detectFace(2000); if (!r.faces) return false; const box=r.faces[0].boundingBox; const cx=box.x+box.width/2; return cx > (video.videoWidth||320)*0.6; })();
    return left && right;
  },
  async ()=>{ await punishmentScoreLoss(20); },
  10000
);

// Task 29: Read paper (manual)
addTask(29,'Read paper','Hold a printed word to camera and confirm.',12,
  async ()=> { return await manualConfirm(12000); },
  async ()=>{ await punishmentScoreLoss(12); punishmentsSpecialApplied.add('halfNext2'); setTimeout(()=>punishmentsSpecialApplied.delete('halfNext2'),2*60000); },
  15000
);

// Task 30: Show green
addTask(30,'Show green','Point camera at a green object.',12,
  async ()=> {
    try{ await requestCamera(); } catch { return await manualConfirm(10000); }
    const ctx = canvas.getContext('2d'); canvas.width=video.videoWidth||320; canvas.height=video.videoHeight||240;
    let total=0; for (let s=0;s<3;s++){ ctx.drawImage(video,0,0,canvas.width,canvas.height); const d=ctx.getImageData(0,0,canvas.width,canvas.height).data; let gsum=0; for (let p=0;p<d.length;p+=4) gsum+=d[p+1]; total+=gsum/(canvas.width*canvas.height); await delay(250); }
    const avg=total/3; println('avgG:'+avg.toFixed(1)); return avg>70;
  },
  async ()=>{ await punishmentScoreLoss(18); punishmentsSpecialApplied.add('skipNextReward'); setTimeout(()=>punishmentsSpecialApplied.delete('skipNextReward'),60000); },
  12000
);

// Task 31: Long cover 5s
addTask(31,'Long cover','Cover camera for ~5 seconds.',18,
  async ()=> {
    const lum = await measureBrightness(5200,400);
    if (lum===null) return await manualConfirm(10000);
    return lum < 25;
  },
  async ()=>{ await punishmentScoreLoss(25); nextTimeoutMultiplier = 0.7; setTimeout(()=>nextTimeoutMultiplier=1,2*60000); },
  6000
);

// Task 32: Type "vault" within 6s
addTask(32,'Type secret','Type the word "vault" within 6 seconds.',12,
  async ()=> {
    const ok = await promptConfirm('Type the word "vault":',6000,'vault');
    return ok;
  },
  async ()=>{ await punishmentScoreLoss(12); lockedUntil = Date.now()+8000; lockUIFor(8000,'Locked due to failure'); },
  6000
);

// Task 33: Clap then silence
addTask(33,'Clap then silence','Clap then remain silent 3s.',18,
  async ()=> {
    const clap = await measureSoundRMS(1200,120); await delay(300); const silence = await measureSoundRMS(3000,200);
    if (clap===null||silence===null) return await manualConfirm(10000);
    return clap>0.08 && silence<0.02;
  },
  async ()=>{ await punishmentScoreLoss(20); addFoul(); },
  8000
);

// Task 34: Quick rotate
addTask(34,'Quick rotate','Rotate device quickly now.',12,
  async ()=> {
    const a1 = await readOrientationOnce(800); await delay(1000); const a2 = await readOrientationOnce(800);
    if (!a1||!a2) return await manualConfirm(8000);
    return Math.abs((a2.alpha||0)-(a1.alpha||0))>40;
  },
  async ()=>{ await punishmentScoreLoss(12); currentIndex--; },
  8000
);

// Task 35: Play music loud
addTask(35,'Play music','Play music loudly near mic.',14,
  async ()=> {
    const rms = await measureSoundRMS(3500,200);
    if (rms===null) return await manualConfirm(10000);
    return rms>0.06;
  },
  async ()=>{ await punishmentScoreLoss(18); rewardsDisabled='freeze'; setTimeout(()=>{ if (rewardsDisabled==='freeze') rewardsDisabled=false; },20000); },
  10000
);

// Task 36: Torch blink
addTask(36,'Torch blink','Turn torch on/off quickly (proxy).',16,
  async ()=> {
    const before = await measureBrightness(800,200); await delay(1200); const after = await measureBrightness(1200,200);
    if (before===null||after===null) return await manualConfirm(10000);
    return after > before * 1.8;
  },
  async ()=>{ await punishmentScoreLoss(20); },
  12000
);

// Task 37: Slow rotate 180
addTask(37,'Slow rotate 180','Rotate ~180 degrees slowly.',15,
  async ()=> {
    const o1 = await readOrientationOnce(1200); await delay(2000); const o2 = await readOrientationOnce(1200);
    if (!o1||!o2) return await manualConfirm(10000);
    return Math.abs((o2.beta||0)-(o1.beta||0))>70;
  },
  async ()=>{ await punishmentScoreLoss(15); punishmentsSpecialApplied.add('halfNext'); setTimeout(()=>punishmentsSpecialApplied.delete('halfNext'),60000); },
  10000
);

// Task 38: Composite (face+mic+motion)
addTask(38,'Composite','Look at camera, shout once, then shake quickly.',30,
  async ()=> {
    const face = await detectFace(2000);
    const mic = await measureSoundRMS(1200,100);
    startMotionCounting(); motionCount=0; await delay(2200); stopMotionCounting();
    const faceOk = face.faces && face.faces.length>0;
    const micOk = mic!==null && mic>0.08;
    const moveOk = motionCount>=2;
    println(`face:${!!faceOk} mic:${(mic||0).toFixed(3)} move:${motionCount}`);
    return faceOk && micOk && moveOk;
  },
  async ()=>{ await punishmentScoreLoss(35); currentIndex = 0; },
  12000
);

// Task 39: Rapid steps
addTask(39,'Rapid steps','Run on spot for 8 seconds.',18,
  async ()=> { startMotionCounting(); motionCount=0; await delay(8000); stopMotionCounting(); println('events:'+motionCount); return motionCount>=8; },
  async ()=>{ await punishmentScoreLoss(20); lockedUntil = Date.now()+30000; lockUIFor(30000,'Cooldown'); },
  10000
);

// Task 40: Final composite & victory
addTask(40,'Final composite','Camera face + shout + small shake to win.',50,
  async ()=> {
    const face = await detectFace(2000);
    const mic = await measureSoundRMS(1200,100);
    startMotionCounting(); motionCount=0; await delay(2200); stopMotionCounting();
    const ok = face.faces && face.faces.length>0 && mic!==null && mic>0.08 && motionCount>=2;
    return !!ok;
  },
  async ()=>{ await punishmentScoreLoss(50); currentIndex = 0; },
  15000
);

// ---------- Task engine ----------
let nextTimeoutMultiplier = 1;

async function runCurrentTask(){
  if (Date.now() < lockedUntil){ println('Input locked ‚Äî wait.'); return; }
  if (currentIndex >= tasks.length){ println('All tasks finished. Final Score: '+score); postEnd(); return; }
  const t = tasks[currentIndex];
  println(`--- TASK ${t.id} : ${t.title} ---`);
  println(t.desc || '');
  taskTitleEl.textContent = `${t.title} (Reward: ${t.reward})`;
  // enforce level: cannot jump to task beyond current level if earlier not completed
  const requiredLevel = Math.floor(currentIndex/5)+1;
  if (requiredLevel > level){ println('You must complete prior level tasks to unlock this level.'); return; }

  // start timer UI
  startTaskTimer(t.timeLimit || taskTimeLimit);

  try {
    const ok = await t.checkFn();
    stopTaskTimer();
    if (ok){
      // reward adjustments
      let gain = t.reward || 10;
      if (punishmentsSpecialApplied.has('halfNext') || punishmentsSpecialApplied.has('halfNext2')) gain = Math.ceil(gain/2);
      if (punishmentsSpecialApplied.has('skipNextReward')) gain = 0;
      if (rewardsDisabled === 'halfRewards') gain = Math.ceil(gain/2);
      if (rewardsDisabled === 'freeze') gain = 0;
      if (punishmentsSpecialApplied.has('muteRewards')) gain = 0;
      addScore(gain);
      println(`‚úÖ Success. Reward: +${gain}`);
    } else {
      stopTaskTimer();
      await applyPunishmentFor(t);
    }
  } catch(e){
    stopTaskTimer();
    println('Error during check ‚Äî fallback to manual confirm.');
    const ok = await manualConfirm(15000);
    if (ok){ addScore(t.reward||10); println('‚úÖ Success (manual confirm).'); }
    else await applyPunishmentFor(t);
  }

  // advance index and handle level progression
  currentIndex++;
  const newLevel = Math.floor(currentIndex/5)+1;
  if (newLevel > level) { setLevel(newLevel); println('üî• LEVEL UP! Now Level '+newLevel); }

  // relax time: enable next after relaxTime (player may press Next to continue sooner)
  await relaxAwaitOrAuto();
}

async function applyPunishmentFor(t){
  addFoul();
  println('Applying punishment for task '+t.id);
  try {
    await t.punishmentFn();
  } catch(e){
    println('Punishment error: '+(e && e.message ? e.message : e));
    await punishmentScoreLoss(10);
  }
  if (foulCount >= 3 && foulCount < 5) println('‚ö†Ô∏è WARNING: Multiple fouls detected.');
  else if (foulCount >= 5){ println('üö® Game Over ‚Äî too many fouls. Resetting game.'); await delay(800); resetGame(); }
}

function runNext(){ if (Date.now() < lockedUntil){ println('Locked: wait...'); return; } runCurrentTask().catch(e=>println('Run error:'+e)); }

// ---------- Task timer & relax handling ----------
function startTaskTimer(ms){
  const tms = ms || taskTimeLimit;
  let left = Math.ceil(tms/1000);
  timeLeftEl.textContent = `${left}s`;
  clearInterval(countdownInterval);
  countdownInterval = setInterval(()=>{ left--; timeLeftEl.textContent = `${left}s`; if (left<=0){ clearInterval(countdownInterval); timeLeftEl.textContent='0s'; println('‚è∞ Task time expired'); /*force auto-fail*/ } },1000);
  // auto fail when timer ends
  clearTimeout(taskTimer);
  taskTimer = setTimeout(async ()=>{ println('‚è∞ Auto-failing task due to timeout'); await applyPunishmentFor(tasks[currentIndex]); currentIndex++; await relaxAwaitOrAuto(); }, tms);
}
function stopTaskTimer(){ clearInterval(countdownInterval); countdownInterval=null; clearTimeout(taskTimer); timeLeftEl.textContent='--'; }
function relaxAwaitOrAuto(){
  return new Promise(resolve=>{
    println(`üòå Relaxing... next task available in ${relaxTime/1000}s (or press Next).`);
    if (autoAdvanceTimer) clearTimeout(autoAdvanceTimer);
    autoAdvanceTimer = setTimeout(()=>{ println('(Auto-schedule next)'); runNext(); resolve(); }, relaxTime);
    // if user presses Next earlier, it will call runNext and resolution will happen there.
    // we resolve anyway on timeout (above).
  });
}

// ---------- Input & controls ----------
startBtn.addEventListener('click', async ()=>{
  println('Requesting permissions: camera & mic & motion (if available). Please allow.');
  try { await requestCamera(); } catch(e){ println('Camera not available'); }
  try { await requestMic(); } catch(e){ println('Mic not available'); }
  recognition = initSpeech();
  if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
    try{ const r = await DeviceMotionEvent.requestPermission(); println('[permission] Device motion: '+r); } catch(e){ println('[permission] Device motion denied'); }
  }
  println('Ready. Press Next Task or Enter to start.');
});

nextBtn.addEventListener('click', ()=>{ runNext(); });

missionsBtn.addEventListener('click', ()=>{ println('Missions list:'); tasks.forEach(t=>println(`${t.id}. ${t.title}`)); });

resetBtn.addEventListener('click', ()=>{ if (confirm('Reset game progress?')) resetGame(); });

cmdInput.addEventListener('keydown', async (e)=>{
  if (e.key === 'Enter'){
    const v = cmdInput.value.trim();
    cmdInput.value = '';
    if (!v) return;
    if (v.toLowerCase() === 'start voice'){
      if (!recognition) { println('[voice] Not supported'); return; }
      println('Listening for 5s...'); const txt = await recognizeOnce(5000); println('Heard: '+(txt||'<none>')); return;
    }
    if (v.toLowerCase() === 'leaderboard'){
      renderLeaderboard(); return;
    }
    // allow CONFIRM used by manual fallback
    if (v.toLowerCase() === 'confirm') { println('Manual confirm recorded.'); hideOverlay(); return; }
    // simple command: if matches current task expected text? many tasks are sensor-based; so we treat non-empty as manual success for manual-type tasks
    println('Input received: '+v);
  }
});

// keyboard Enter to act as Next
document.addEventListener('keydown', (e)=>{ if (e.key==='Enter'){ if (Date.now() >= lockedUntil) runNext(); else println('Locked'); } });

// ---------- Speech wrapper ----------
function initSpeech(){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { println('[voice] Web Speech API not supported.'); return null; }
  const r = new SR();
  r.lang = 'en-US'; r.interimResults = false; r.maxAlternatives = 3;
  println('[voice] SpeechRecognition ready.');
  return r;
}
function recognizeOnce(timeout=5000){
  return new Promise(resolve=>{
    if (!recognition){ resolve(null); return; }
    let finished=false;
    const onResult = (e)=>{ if (finished) return; finished=true; const t = e.results[0][0].transcript; cleanup(); resolve(t); };
    const onError = ()=>{ if (finished) return; finished=true; cleanup(); resolve(null); };
    const cleanup = ()=>{ recognition.removeEventListener('result', onResult); recognition.removeEventListener('error', onError); try{ recognition.stop(); }catch{} };
    recognition.addEventListener('result', onResult);
    recognition.addEventListener('error', onError);
    try{ recognition.start(); } catch(e){ cleanup(); resolve(null); }
    setTimeout(()=>{ if (!finished){ finished=true; cleanup(); resolve(null); } }, timeout);
  });
}

// ---------- Punishment helper wrappers used by tasks ----------
async function lockUIFor(ms, reason){
  const screenEl = document.getElementById('screen');
  println(`UI locked for ${Math.ceil(ms/1000)}s: ${reason}`);
  screenEl.classList.add('locked');
  lockedUntil = Date.now() + ms;
  await delay(ms);
  screenEl.classList.remove('locked');
  println('UI unlocked.');
}

// ---------- end of run helpers ----------
function postEnd(){
  println('Game ended. Submit score? Type name in prompt.');
  const name = prompt('Enter name to submit score (local):') || 'Player';
  submitScore(name, score);
  renderLeaderboard();
  println('Score saved locally.');
}

// ---------- leaderboard functions ----------
function submitScore(name, points){
  const lb = loadLeaderboard();
  lb.push({name, points});
  lb.sort((a,b)=>b.points - a.points);
  saveLeaderboard(lb.slice(0,5));
  // optional: call external leaderboard API here
  // fetch('https://your-api.example.com/submit', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({name,points})});
}
function loadLeaderboard(){ return JSON.parse(localStorage.getItem('sensorGameLB_v1') || '[]'); }
function saveLeaderboard(list){ localStorage.setItem('sensorGameLB_v1', JSON.stringify(list)); renderLeaderboard(); }
function renderLeaderboard(){
  const list = loadLeaderboard();
  lbEl.innerHTML = '';
  for (let i=0;i<list.length;i++){
    const it = list[i];
    const li = document.createElement('li');
    li.textContent = `${i+1}. ${it.name} ‚Äî ${it.points}`;
    lbEl.appendChild(li);
  }
}

// ---------- Initialization prints ----------
println('Sensor Task Game ‚Äî 40 Missions (Face & Voice)');
println('Click "Start Game" to request permissions (camera, mic, motion).');
println('Then press Next Task or Enter to run tasks one by one.');
println('Each task has a time limit and there is a relax period between tasks.');
println('Face detection uses browser FaceDetector if available. Voice uses Web Speech API.');
println('');
setScore(0); addFoul(0);
renderLeaderboard();

// ---------- Helper: wait for Enter key (used in some tasks) ----------
function waitForEnter(ms=3000){
  return new Promise(resolve=>{
    const handler = (e)=>{ if (e.key==='Enter'){ cleanup(); resolve(true); } };
    const cleanup = ()=>{ document.removeEventListener('keydown', handler); };
    document.addEventListener('keydown', handler);
    setTimeout(()=>{ cleanup(); resolve(false); }, ms);
  });
}

// ---------- promptConfirm utility ----------
function promptConfirm(msg, timeout=10000, expectedRegex='.*'){
  return new Promise(resolve=>{
    const ans = prompt(msg);
    if (ans === null) return resolve(false);
    const re = new RegExp(expectedRegex,'i');
    resolve(re.test(ans.trim()));
  });
}

// ---------- reset game ----------
function resetGame(){
  setScore(0); foulCount=0; foulEl.textContent=foulCount; currentIndex=0; setLevel(1); println('Game reset.'); punishmentsSpecialApplied.clear(); rewardsDisabled=false; nextTimeoutMultiplier=1; lockedUntil=0;
}

// ---------- End of script ----------
</script>
</body>
</html>